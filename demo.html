<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>@motioneffector/dialogue - Demo</title>
  <style>
/* ============================================
   RESET & BASE
   ============================================ */

*, *::before, *::after {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}

html {
  font-size: 16px;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

body {
  font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", "Noto Sans", Helvetica, Arial, sans-serif;
  font-size: 1rem;
  line-height: 1.5;
  color: #e6edf3;
  background: #0d1117;
  min-height: 100vh;
}

/* ============================================
   CSS VARIABLES
   ============================================ */

:root {
  /* Backgrounds */
  --bg-primary: #0d1117;
  --bg-secondary: #161b22;
  --bg-tertiary: #21262d;
  --bg-hover: #30363d;

  /* Borders */
  --border-default: #30363d;
  --border-muted: #21262d;

  /* Text */
  --text-primary: #e6edf3;
  --text-secondary: #8b949e;
  --text-muted: #6e7681;
  --text-link: #58a6ff;

  /* Accents */
  --accent-blue: #1f6feb;
  --accent-blue-hover: #388bfd;
  --accent-green: #238636;
  --accent-green-bright: #3fb950;
  --accent-red: #da3633;
  --accent-red-bright: #f85149;
  --accent-yellow: #d29922;
  --accent-yellow-bright: #e3b341;
  --accent-purple: #8957e5;

  /* Spacing */
  --space-xs: 4px;
  --space-sm: 8px;
  --space-md: 16px;
  --space-lg: 24px;
  --space-xl: 32px;
  --space-xxl: 48px;

  /* Radii */
  --radius-sm: 4px;
  --radius-md: 6px;
  --radius-lg: 8px;
  --radius-xl: 12px;

  /* Typography */
  --font-mono: ui-monospace, SFMono-Regular, "SF Mono", Menlo, Consolas, "Liberation Mono", monospace;
  --font-size-xs: 0.75rem;
  --font-size-sm: 0.875rem;
  --font-size-md: 1rem;
  --font-size-lg: 1.25rem;
  --font-size-xl: 1.5rem;
  --font-size-xxl: 2rem;

  /* Shadows */
  --shadow-sm: 0 1px 2px rgba(0, 0, 0, 0.3);
  --shadow-md: 0 4px 8px rgba(0, 0, 0, 0.3);
  --shadow-lg: 0 8px 16px rgba(0, 0, 0, 0.4);

  /* Transitions */
  --transition-fast: 0.1s ease;
  --transition-normal: 0.2s ease;
  --transition-slow: 0.3s ease;
}

/* ============================================
   LAYOUT
   ============================================ */

.page {
  max-width: 1200px;
  margin: 0 auto;
  padding: var(--space-xl);
}

/* ============================================
   HEADER
   ============================================ */

.header {
  margin-bottom: var(--space-xxl);
  padding-bottom: var(--space-xl);
  border-bottom: 1px solid var(--border-default);
}

.header-title {
  font-size: var(--font-size-xxl);
  font-weight: 600;
  color: var(--text-primary);
  margin-bottom: var(--space-sm);
}

.header-description {
  font-size: var(--font-size-lg);
  color: var(--text-secondary);
  margin-bottom: var(--space-lg);
}

.header-links {
  display: flex;
  gap: var(--space-md);
}

.header-link {
  display: inline-flex;
  align-items: center;
  gap: var(--space-xs);
  color: var(--text-link);
  text-decoration: none;
  font-size: var(--font-size-sm);
  padding: var(--space-xs) var(--space-sm);
  border-radius: var(--radius-md);
  transition: background var(--transition-fast);
}

.header-link:hover {
  background: var(--bg-tertiary);
  text-decoration: underline;
}

/* ============================================
   EXHIBITS
   ============================================ */

.exhibits {
  display: flex;
  flex-direction: column;
  gap: var(--space-xxl);
}

.exhibit {
  background: var(--bg-secondary);
  border: 1px solid var(--border-default);
  border-radius: var(--radius-xl);
  overflow: hidden;
}

.exhibit-header {
  padding: var(--space-lg);
  border-bottom: 1px solid var(--border-default);
}

.exhibit-title {
  font-size: var(--font-size-xl);
  font-weight: 600;
  color: var(--text-primary);
  margin-bottom: var(--space-xs);
}

.exhibit-description {
  font-size: var(--font-size-md);
  color: var(--text-secondary);
}

.exhibit-content {
  padding: var(--space-lg);
}

.exhibit-interactive {
  background: var(--bg-primary);
  border: 1px solid var(--border-muted);
  border-radius: var(--radius-lg);
  min-height: 200px;
  padding: var(--space-lg);
  margin-bottom: var(--space-lg);
}

.exhibit-controls {
  display: flex;
  flex-wrap: wrap;
  gap: var(--space-sm);
  padding: var(--space-md);
  background: var(--bg-tertiary);
  border-radius: var(--radius-md);
  margin-bottom: var(--space-lg);
}

.exhibit-state {
  padding: var(--space-md);
  background: var(--bg-primary);
  border: 1px solid var(--border-muted);
  border-radius: var(--radius-md);
  font-family: var(--font-mono);
  font-size: var(--font-size-sm);
}

.exhibit-state-title {
  font-size: var(--font-size-xs);
  font-weight: 600;
  color: var(--text-muted);
  text-transform: uppercase;
  letter-spacing: 0.5px;
  margin-bottom: var(--space-sm);
}

/* ============================================
   BUTTONS
   ============================================ */

.btn {
  display: inline-flex;
  align-items: center;
  justify-content: center;
  gap: var(--space-xs);
  padding: var(--space-sm) var(--space-md);
  font-size: var(--font-size-sm);
  font-weight: 500;
  border-radius: var(--radius-md);
  border: 1px solid transparent;
  cursor: pointer;
  transition: all var(--transition-fast);
  white-space: nowrap;
}

.btn:disabled {
  opacity: 0.5;
  cursor: not-allowed;
}

.btn-primary {
  background: var(--accent-blue);
  color: white;
  border-color: var(--accent-blue);
}

.btn-primary:hover:not(:disabled) {
  background: var(--accent-blue-hover);
  border-color: var(--accent-blue-hover);
}

.btn-secondary {
  background: var(--bg-tertiary);
  color: var(--text-primary);
  border-color: var(--border-default);
}

.btn-secondary:hover:not(:disabled) {
  background: var(--bg-hover);
}

.btn-danger {
  background: var(--accent-red);
  color: white;
  border-color: var(--accent-red);
}

.btn-danger:hover:not(:disabled) {
  background: var(--accent-red-bright);
}

.btn-success {
  background: var(--accent-green);
  color: white;
  border-color: var(--accent-green);
}

.btn-success:hover:not(:disabled) {
  background: var(--accent-green-bright);
}

.btn-small {
  padding: var(--space-xs) var(--space-sm);
  font-size: var(--font-size-xs);
}

/* ============================================
   INPUTS
   ============================================ */

.input {
  background: var(--bg-primary);
  border: 1px solid var(--border-default);
  border-radius: var(--radius-md);
  padding: var(--space-sm) var(--space-md);
  font-size: var(--font-size-sm);
  color: var(--text-primary);
  transition: border-color var(--transition-fast);
}

.input:focus {
  outline: none;
  border-color: var(--accent-blue);
}

.input::placeholder {
  color: var(--text-muted);
}

.input-mono {
  font-family: var(--font-mono);
}

select.input {
  cursor: pointer;
}

textarea.input {
  resize: vertical;
  min-height: 80px;
  font-family: inherit;
}

/* ============================================
   TOGGLE
   ============================================ */

.toggle {
  display: inline-flex;
  align-items: center;
  gap: var(--space-sm);
  cursor: pointer;
  font-size: var(--font-size-sm);
}

.toggle-switch {
  position: relative;
  width: 40px;
  height: 22px;
  background: var(--bg-hover);
  border-radius: 11px;
  transition: background var(--transition-normal);
}

.toggle-switch::after {
  content: '';
  position: absolute;
  top: 3px;
  left: 3px;
  width: 16px;
  height: 16px;
  background: var(--text-primary);
  border-radius: 50%;
  transition: transform var(--transition-normal);
}

.toggle input {
  display: none;
}

.toggle input:checked + .toggle-switch {
  background: var(--accent-blue);
}

.toggle input:checked + .toggle-switch::after {
  transform: translateX(18px);
}

.toggle-label {
  color: var(--text-secondary);
}

/* ============================================
   TAGS / BADGES
   ============================================ */

.tag {
  display: inline-block;
  padding: var(--space-xs) var(--space-sm);
  font-size: var(--font-size-xs);
  font-weight: 500;
  border-radius: var(--radius-sm);
  background: var(--bg-tertiary);
  color: var(--text-secondary);
}

.tag-blue {
  background: rgba(31, 111, 235, 0.2);
  color: var(--accent-blue-hover);
}

.tag-green {
  background: rgba(35, 134, 54, 0.2);
  color: var(--accent-green-bright);
}

.tag-red {
  background: rgba(218, 54, 51, 0.2);
  color: var(--accent-red-bright);
}

.tag-yellow {
  background: rgba(210, 153, 34, 0.2);
  color: var(--accent-yellow-bright);
}

.tag-purple {
  background: rgba(137, 87, 229, 0.2);
  color: var(--accent-purple);
}

/* ============================================
   TEST RUNNER
   ============================================ */

.test-runner {
  margin-top: var(--space-xxl);
  background: var(--bg-secondary);
  border: 1px solid var(--border-default);
  border-radius: var(--radius-xl);
  overflow: hidden;
}

.test-runner-header {
  padding: var(--space-lg);
  border-bottom: 1px solid var(--border-default);
  display: flex;
  align-items: center;
  justify-content: space-between;
}

.test-runner-title {
  font-size: var(--font-size-xl);
  font-weight: 600;
}

.test-runner-actions {
  display: flex;
  gap: var(--space-sm);
}

.test-runner-content {
  padding: var(--space-lg);
}

.test-progress {
  margin-bottom: var(--space-lg);
}

.test-progress-bar {
  height: 8px;
  background: var(--bg-tertiary);
  border-radius: 4px;
  overflow: hidden;
  margin-bottom: var(--space-sm);
}

.test-progress-fill {
  height: 100%;
  background: var(--accent-blue);
  border-radius: 4px;
  transition: width var(--transition-fast);
  width: 0%;
}

.test-progress-fill.success {
  background: var(--accent-green);
}

.test-progress-fill.failure {
  background: var(--accent-red);
}

.test-progress-text {
  font-size: var(--font-size-sm);
  color: var(--text-secondary);
}

.test-output {
  background: var(--bg-primary);
  border: 1px solid var(--border-muted);
  border-radius: var(--radius-md);
  max-height: 400px;
  overflow-y: auto;
  font-family: var(--font-mono);
  font-size: var(--font-size-sm);
}

.test-output-empty {
  padding: var(--space-xl);
  text-align: center;
  color: var(--text-muted);
}

.test-item {
  padding: var(--space-sm) var(--space-md);
  border-bottom: 1px solid var(--border-muted);
  display: flex;
  align-items: flex-start;
  gap: var(--space-sm);
}

.test-item:last-child {
  border-bottom: none;
}

.test-icon {
  flex-shrink: 0;
  font-size: var(--font-size-md);
}

.test-icon.pass {
  color: var(--accent-green-bright);
}

.test-icon.fail {
  color: var(--accent-red-bright);
}

.test-name {
  color: var(--text-primary);
}

.test-error {
  color: var(--accent-red-bright);
  font-size: var(--font-size-xs);
  margin-top: var(--space-xs);
}

.test-summary {
  margin-top: var(--space-lg);
  padding: var(--space-md);
  background: var(--bg-tertiary);
  border-radius: var(--radius-md);
  font-size: var(--font-size-sm);
  display: flex;
  gap: var(--space-lg);
}

.test-summary-item {
  display: flex;
  align-items: center;
  gap: var(--space-xs);
}

.test-summary-item.passed {
  color: var(--accent-green-bright);
}

.test-summary-item.failed {
  color: var(--accent-red-bright);
}

.test-summary-item.skipped {
  color: var(--text-muted);
}

/* ============================================
   UTILITY CLASSES
   ============================================ */

.text-primary { color: var(--text-primary); }
.text-secondary { color: var(--text-secondary); }
.text-muted { color: var(--text-muted); }
.text-success { color: var(--accent-green-bright); }
.text-error { color: var(--accent-red-bright); }
.text-warning { color: var(--accent-yellow-bright); }

.font-mono { font-family: var(--font-mono); }

.flex { display: flex; }
.flex-col { flex-direction: column; }
.flex-wrap { flex-wrap: wrap; }
.items-center { align-items: center; }
.justify-between { justify-content: space-between; }
.gap-xs { gap: var(--space-xs); }
.gap-sm { gap: var(--space-sm); }
.gap-md { gap: var(--space-md); }
.gap-lg { gap: var(--space-lg); }

.mt-sm { margin-top: var(--space-sm); }
.mt-md { margin-top: var(--space-md); }
.mt-lg { margin-top: var(--space-lg); }
.mb-sm { margin-bottom: var(--space-sm); }
.mb-md { margin-bottom: var(--space-md); }
.mb-lg { margin-bottom: var(--space-lg); }

.p-sm { padding: var(--space-sm); }
.p-md { padding: var(--space-md); }
.p-lg { padding: var(--space-lg); }

.hidden { display: none; }

/* ============================================
   SCROLLBAR
   ============================================ */

::-webkit-scrollbar {
  width: 8px;
  height: 8px;
}

::-webkit-scrollbar-track {
  background: var(--bg-secondary);
}

::-webkit-scrollbar-thumb {
  background: var(--bg-hover);
  border-radius: 4px;
}

::-webkit-scrollbar-thumb:hover {
  background: var(--border-default);
}

/* ============================================
   EXHIBIT 1: THE CONVERSATION
   ============================================ */

.conversation-layout {
  display: grid;
  grid-template-columns: 1fr;
  gap: var(--space-lg);
}

@media (min-width: 768px) {
  .conversation-layout {
    grid-template-columns: 120px 1fr;
  }
}

.speaker-portrait {
  width: 100px;
  height: 100px;
  background: var(--bg-tertiary);
  border-radius: var(--radius-lg);
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 48px;
  border: 2px solid var(--border-default);
  transition: border-color var(--transition-normal);
}

.speaker-portrait.active {
  border-color: var(--accent-blue);
}

.speaker-name {
  text-align: center;
  margin-top: var(--space-sm);
  font-weight: 600;
  color: var(--text-primary);
}

.dialogue-box {
  background: var(--bg-tertiary);
  border-radius: var(--radius-lg);
  padding: var(--space-lg);
  min-height: 150px;
}

.dialogue-text {
  font-size: var(--font-size-lg);
  line-height: 1.6;
  margin-bottom: var(--space-lg);
}

.dialogue-text .interpolation {
  background: var(--accent-purple);
  color: white;
  padding: 2px 6px;
  border-radius: var(--radius-sm);
  font-family: var(--font-mono);
  transition: all 0.5s ease;
}

.dialogue-text .interpolation.resolved {
  background: var(--accent-green);
}

.choices-list {
  display: flex;
  flex-direction: column;
  gap: var(--space-sm);
}

.choice-btn {
  display: flex;
  align-items: center;
  gap: var(--space-sm);
  padding: var(--space-md);
  background: var(--bg-secondary);
  border: 1px solid var(--border-default);
  border-radius: var(--radius-md);
  color: var(--text-primary);
  cursor: pointer;
  transition: all var(--transition-fast);
  text-align: left;
}

.choice-btn:hover:not(:disabled) {
  background: var(--bg-hover);
  border-color: var(--accent-blue);
}

.choice-btn:disabled {
  opacity: 0.5;
  cursor: not-allowed;
}

.choice-btn .action-indicator {
  color: var(--accent-yellow);
}

.action-stream {
  background: var(--bg-primary);
  border: 1px solid var(--border-muted);
  border-radius: var(--radius-md);
  padding: var(--space-md);
  margin-top: var(--space-lg);
  max-height: 150px;
  overflow-y: auto;
}

.action-stream-title {
  font-size: var(--font-size-xs);
  font-weight: 600;
  color: var(--text-muted);
  text-transform: uppercase;
  margin-bottom: var(--space-sm);
}

.action-item {
  font-family: var(--font-mono);
  font-size: var(--font-size-sm);
  padding: var(--space-xs) 0;
  color: var(--text-secondary);
  display: flex;
  align-items: center;
  gap: var(--space-sm);
  animation: slideIn 0.3s ease;
}

@keyframes slideIn {
  from {
    opacity: 0;
    transform: translateX(-10px);
  }
  to {
    opacity: 1;
    transform: translateX(0);
  }
}

.action-item .action-type {
  color: var(--accent-purple);
}

.action-item .action-flag {
  color: var(--accent-blue);
}

.action-item .action-value {
  color: var(--accent-green);
}

.flags-panel {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: var(--space-md);
  margin-top: var(--space-lg);
}

.flag-group {
  background: var(--bg-primary);
  border: 1px solid var(--border-muted);
  border-radius: var(--radius-md);
  padding: var(--space-md);
}

.flag-group-title {
  font-size: var(--font-size-xs);
  font-weight: 600;
  color: var(--text-muted);
  text-transform: uppercase;
  margin-bottom: var(--space-sm);
}

.flag-item {
  display: flex;
  align-items: center;
  gap: var(--space-sm);
  padding: var(--space-xs) 0;
  font-family: var(--font-mono);
  font-size: var(--font-size-sm);
}

.flag-name {
  color: var(--text-secondary);
  min-width: 80px;
}

.flag-bar {
  flex: 1;
  height: 16px;
  background: var(--bg-tertiary);
  border-radius: var(--radius-sm);
  overflow: hidden;
  position: relative;
}

.flag-bar-fill {
  height: 100%;
  background: var(--accent-blue);
  transition: width 0.3s ease;
  border-radius: var(--radius-sm);
}

.flag-bar-value {
  position: absolute;
  right: var(--space-sm);
  top: 50%;
  transform: translateY(-50%);
  font-size: var(--font-size-xs);
  color: var(--text-primary);
}

.flag-bool {
  width: 16px;
  height: 16px;
  border-radius: 50%;
  border: 2px solid var(--border-default);
  transition: all 0.2s ease;
}

.flag-bool.true {
  background: var(--accent-green);
  border-color: var(--accent-green);
}

.flag-bool.false {
  background: transparent;
}

.dialogue-ended {
  text-align: center;
  padding: var(--space-xl);
  color: var(--text-muted);
}

/* ============================================
   EXHIBIT 2: THE CONDITION LABORATORY
   ============================================ */

.lab-layout {
  display: flex;
  flex-direction: column;
  gap: var(--space-lg);
}

.lab-inputs {
  background: var(--bg-tertiary);
  border-radius: var(--radius-md);
  padding: var(--space-lg);
}

.lab-inputs-title {
  font-size: var(--font-size-sm);
  font-weight: 600;
  color: var(--text-muted);
  text-transform: uppercase;
  margin-bottom: var(--space-md);
}

.lab-input-row {
  display: flex;
  align-items: center;
  gap: var(--space-md);
  padding: var(--space-sm) 0;
}

.lab-input-name {
  min-width: 100px;
  font-family: var(--font-mono);
  color: var(--text-secondary);
}

.lab-slider {
  flex: 1;
  height: 8px;
  -webkit-appearance: none;
  appearance: none;
  background: var(--bg-hover);
  border-radius: 4px;
  cursor: pointer;
}

.lab-slider::-webkit-slider-thumb {
  -webkit-appearance: none;
  width: 20px;
  height: 20px;
  background: var(--accent-blue);
  border-radius: 50%;
  cursor: pointer;
  transition: transform var(--transition-fast);
}

.lab-slider::-webkit-slider-thumb:hover {
  transform: scale(1.2);
}

.lab-switch {
  display: flex;
  align-items: center;
  gap: var(--space-sm);
}

.lab-switch-track {
  width: 60px;
  height: 28px;
  background: var(--bg-hover);
  border-radius: 14px;
  cursor: pointer;
  position: relative;
  transition: background var(--transition-normal);
}

.lab-switch-track.on {
  background: var(--accent-green);
}

.lab-switch-thumb {
  position: absolute;
  top: 4px;
  left: 4px;
  width: 20px;
  height: 20px;
  background: white;
  border-radius: 50%;
  transition: transform var(--transition-normal);
}

.lab-switch-track.on .lab-switch-thumb {
  transform: translateX(32px);
}

.lab-switch-label {
  font-size: var(--font-size-sm);
  color: var(--text-muted);
}

.lab-input-value {
  min-width: 60px;
  text-align: right;
  font-family: var(--font-mono);
  color: var(--text-primary);
}

.lab-select {
  padding: var(--space-sm) var(--space-md);
  background: var(--bg-primary);
  border: 1px solid var(--border-default);
  border-radius: var(--radius-md);
  color: var(--text-primary);
  cursor: pointer;
}

.lab-gates {
  background: var(--bg-primary);
  border: 1px solid var(--border-muted);
  border-radius: var(--radius-md);
  padding: var(--space-lg);
  min-height: 200px;
}

.lab-gates-title {
  font-size: var(--font-size-sm);
  font-weight: 600;
  color: var(--text-muted);
  text-transform: uppercase;
  margin-bottom: var(--space-md);
}

.condition-row {
  display: flex;
  align-items: center;
  gap: var(--space-md);
  padding: var(--space-md);
  background: var(--bg-tertiary);
  border-radius: var(--radius-md);
  margin-bottom: var(--space-sm);
  transition: all var(--transition-normal);
}

.condition-wire {
  width: 40px;
  height: 4px;
  background: var(--bg-hover);
  border-radius: 2px;
  position: relative;
  overflow: hidden;
}

.condition-wire.active {
  background: var(--accent-green);
}

.condition-wire .pulse {
  position: absolute;
  width: 10px;
  height: 100%;
  background: white;
  border-radius: 2px;
  animation: pulseThroughWire 0.3s ease;
}

@keyframes pulseThroughWire {
  from { left: -10px; }
  to { left: 100%; }
}

.condition-check {
  display: flex;
  align-items: center;
  gap: var(--space-sm);
  font-family: var(--font-mono);
  font-size: var(--font-size-sm);
}

.condition-status {
  padding: var(--space-xs) var(--space-sm);
  border-radius: var(--radius-sm);
  font-size: var(--font-size-xs);
  font-weight: 600;
}

.condition-status.pass {
  background: rgba(35, 134, 54, 0.2);
  color: var(--accent-green-bright);
}

.condition-status.fail {
  background: rgba(218, 54, 51, 0.2);
  color: var(--accent-red-bright);
}

.condition-gate {
  padding: var(--space-sm) var(--space-md);
  background: var(--bg-secondary);
  border: 1px solid var(--border-default);
  border-radius: var(--radius-sm);
  font-size: var(--font-size-xs);
  font-weight: 600;
  color: var(--text-muted);
}

.condition-gate.active {
  border-color: var(--accent-green);
  color: var(--accent-green);
}

.lab-outputs {
  background: var(--bg-tertiary);
  border-radius: var(--radius-md);
  padding: var(--space-lg);
}

.lab-outputs-title {
  font-size: var(--font-size-sm);
  font-weight: 600;
  color: var(--text-muted);
  text-transform: uppercase;
  margin-bottom: var(--space-md);
}

.output-row {
  display: flex;
  align-items: center;
  gap: var(--space-md);
  padding: var(--space-sm) 0;
}

.output-bulb {
  width: 24px;
  height: 24px;
  border-radius: 50%;
  background: var(--bg-hover);
  border: 2px solid var(--border-default);
  transition: all var(--transition-normal);
}

.output-bulb.lit {
  background: var(--accent-yellow);
  border-color: var(--accent-yellow);
  box-shadow: 0 0 10px var(--accent-yellow);
}

.output-text {
  flex: 1;
  font-size: var(--font-size-sm);
}

.output-status {
  font-size: var(--font-size-xs);
  color: var(--text-muted);
}

.output-status.available {
  color: var(--accent-green-bright);
}

/* ============================================
   EXHIBIT 3: THE TIME MACHINE
   ============================================ */

.time-machine-layout {
  display: flex;
  flex-direction: column;
  gap: var(--space-lg);
}

.current-moment {
  background: var(--bg-tertiary);
  border-radius: var(--radius-md);
  padding: var(--space-lg);
}

.current-moment-text {
  font-size: var(--font-size-lg);
  margin-bottom: var(--space-md);
}

.current-moment-choices {
  display: flex;
  flex-direction: column;
  gap: var(--space-sm);
}

.timeline-section {
  background: var(--bg-primary);
  border: 1px solid var(--border-muted);
  border-radius: var(--radius-md);
  padding: var(--space-lg);
}

.timeline-title {
  font-size: var(--font-size-sm);
  font-weight: 600;
  color: var(--text-muted);
  text-transform: uppercase;
  margin-bottom: var(--space-md);
}

.timeline-track {
  display: flex;
  align-items: center;
  gap: var(--space-sm);
  padding: var(--space-md) 0;
  overflow-x: auto;
}

.timeline-node {
  flex-shrink: 0;
  width: 60px;
  height: 60px;
  background: var(--bg-tertiary);
  border: 2px solid var(--border-default);
  border-radius: var(--radius-md);
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  transition: all var(--transition-fast);
}

.timeline-node:hover {
  border-color: var(--accent-blue);
}

.timeline-node.current {
  border-color: var(--accent-green);
  background: rgba(35, 134, 54, 0.2);
}

.timeline-node-number {
  font-size: var(--font-size-xs);
  color: var(--text-muted);
}

.timeline-node-icon {
  font-size: 24px;
}

.timeline-connector {
  width: 20px;
  height: 2px;
  background: var(--border-default);
  flex-shrink: 0;
}

.timeline-controls {
  display: flex;
  align-items: center;
  gap: var(--space-md);
  margin-top: var(--space-md);
}

.timeline-slider {
  flex: 1;
  height: 8px;
  -webkit-appearance: none;
  appearance: none;
  background: var(--bg-hover);
  border-radius: 4px;
  cursor: pointer;
}

.timeline-slider::-webkit-slider-thumb {
  -webkit-appearance: none;
  width: 20px;
  height: 20px;
  background: var(--accent-green);
  border-radius: 50%;
  cursor: pointer;
}

.state-at-moment {
  display: grid;
  grid-template-columns: 1fr 1fr 1fr;
  gap: var(--space-md);
  margin-top: var(--space-lg);
}

@media (max-width: 768px) {
  .state-at-moment {
    grid-template-columns: 1fr;
  }
}

.state-panel {
  background: var(--bg-tertiary);
  border-radius: var(--radius-md);
  padding: var(--space-md);
}

.state-panel-title {
  font-size: var(--font-size-xs);
  font-weight: 600;
  color: var(--text-muted);
  text-transform: uppercase;
  margin-bottom: var(--space-sm);
}

.save-slots {
  display: grid;
  grid-template-columns: repeat(4, 1fr);
  gap: var(--space-md);
  margin-top: var(--space-lg);
}

@media (max-width: 768px) {
  .save-slots {
    grid-template-columns: repeat(2, 1fr);
  }
}

.save-slot {
  background: var(--bg-tertiary);
  border: 2px dashed var(--border-default);
  border-radius: var(--radius-md);
  padding: var(--space-md);
  min-height: 120px;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  transition: all var(--transition-fast);
}

.save-slot:hover {
  border-color: var(--accent-blue);
}

.save-slot.filled {
  border-style: solid;
  border-color: var(--border-default);
}

.save-slot-title {
  font-size: var(--font-size-xs);
  font-weight: 600;
  color: var(--text-muted);
  margin-bottom: var(--space-sm);
}

.save-slot-preview {
  font-size: 32px;
  margin-bottom: var(--space-xs);
}

.save-slot-info {
  font-size: var(--font-size-xs);
  color: var(--text-secondary);
  text-align: center;
}

.save-slot-empty {
  color: var(--text-muted);
}

.save-slot-actions {
  display: flex;
  gap: var(--space-xs);
  margin-top: var(--space-sm);
}
  </style>
</head>
<body>
  <div class="page">
    <header class="header">
      <h1 class="header-title">@motioneffector/dialogue</h1>
      <p class="header-description">A lightweight, type-safe branching dialogue system for games and interactive fiction.</p>
      <nav class="header-links">
        <a href="https://www.npmjs.com/package/@motioneffector/dialogue" class="header-link" target="_blank">
          üì¶ npm
        </a>
        <a href="https://github.com/motioneffector/dialogue" class="header-link" target="_blank">
          üíª GitHub
        </a>
        <a href="https://github.com/motioneffector/dialogue/wiki" class="header-link" target="_blank">
          üìñ Manual
        </a>
      </nav>
    </header>

    <main class="exhibits">
      <!-- Exhibit 1: The Conversation -->
      <section class="exhibit">
        <div class="exhibit-header">
          <h2 class="exhibit-title">The Conversation</h2>
          <p class="exhibit-description">Core dialogue experience - branching paths, choices, speakers, actions executing visibly, text interpolation as a visible transformation.</p>
        </div>
        <div class="exhibit-content">
          <div class="exhibit-interactive" id="exhibit-1">
            <div class="conversation-layout">
              <div class="speaker-column">
                <div class="speaker-portrait active" id="speaker-portrait">üè™</div>
                <div class="speaker-name" id="speaker-name">Merchant</div>
              </div>
              <div class="dialogue-column">
                <div class="dialogue-box">
                  <div class="dialogue-text" id="dialogue-text">Loading...</div>
                  <div class="choices-list" id="choices-list"></div>
                  <div class="dialogue-ended hidden" id="dialogue-ended">
                    <p>Dialogue has ended.</p>
                    <button class="btn btn-primary" onclick="restartDialogue()">Restart</button>
                  </div>
                </div>
              </div>
            </div>
            <div class="action-stream">
              <div class="action-stream-title">Action Stream</div>
              <div id="action-stream-content"></div>
            </div>
            <div class="flags-panel">
              <div class="flag-group">
                <div class="flag-group-title">Game Flags</div>
                <div id="game-flags"></div>
              </div>
              <div class="flag-group">
                <div class="flag-group-title">Conversation Flags</div>
                <div id="conv-flags"></div>
              </div>
            </div>
          </div>
          <div class="exhibit-controls">
            <button class="btn btn-secondary" onclick="restartDialogue()">Restart</button>
            <label class="toggle">
              <input type="checkbox" id="show-all-actions" checked>
              <span class="toggle-switch"></span>
              <span class="toggle-label">Show All Actions</span>
            </label>
          </div>
        </div>
      </section>

      <!-- Exhibit 2: The Condition Laboratory -->
      <section class="exhibit">
        <div class="exhibit-header">
          <h2 class="exhibit-title">The Condition Laboratory</h2>
          <p class="exhibit-description">How conditions control choice visibility with a hands-on, circuit-board style interaction.</p>
        </div>
        <div class="exhibit-content">
          <div class="exhibit-interactive" id="exhibit-2">
            <div class="lab-layout">
              <div class="lab-inputs">
                <div class="lab-inputs-title">Inputs (drag sliders, flip switches)</div>
                <div class="lab-input-row">
                  <span class="lab-input-name">gold</span>
                  <input type="range" class="lab-slider" id="lab-gold" min="0" max="250" value="120">
                  <span class="lab-input-value" id="lab-gold-value">120</span>
                </div>
                <div class="lab-input-row">
                  <span class="lab-input-name">hasKey</span>
                  <div class="lab-switch">
                    <div class="lab-switch-track" id="lab-hasKey" onclick="toggleLabSwitch('hasKey')">
                      <div class="lab-switch-thumb"></div>
                    </div>
                    <span class="lab-switch-label" id="lab-hasKey-label">OFF</span>
                  </div>
                </div>
                <div class="lab-input-row">
                  <span class="lab-input-name">reputation</span>
                  <input type="range" class="lab-slider" id="lab-reputation" min="-100" max="100" value="30">
                  <span class="lab-input-value" id="lab-reputation-value">30</span>
                </div>
                <div class="lab-input-row">
                  <span class="lab-input-name">class</span>
                  <select class="lab-select" id="lab-class">
                    <option value="warrior" selected>warrior</option>
                    <option value="mage">mage</option>
                    <option value="rogue">rogue</option>
                  </select>
                </div>
              </div>
              <div class="lab-gates">
                <div class="lab-gates-title">Logic Gates (watch signals flow through)</div>
                <div id="lab-conditions"></div>
              </div>
              <div class="lab-outputs">
                <div class="lab-outputs-title">Outputs (choices light up when available)</div>
                <div id="lab-outputs"></div>
              </div>
            </div>
          </div>
          <div class="exhibit-controls">
            <button class="btn btn-secondary" onclick="randomizeLabInputs()">Randomize Inputs</button>
          </div>
        </div>
      </section>

      <!-- Exhibit 3: The Time Machine -->
      <section class="exhibit">
        <div class="exhibit-header">
          <h2 class="exhibit-title">The Time Machine</h2>
          <p class="exhibit-description">History tracking, navigation, and state management - with VISUAL state, not JSON.</p>
        </div>
        <div class="exhibit-content">
          <div class="exhibit-interactive" id="exhibit-3">
            <div class="time-machine-layout">
              <div class="current-moment">
                <div class="current-moment-text" id="tm-current-text">Loading...</div>
                <div class="current-moment-choices" id="tm-choices"></div>
              </div>
              <div class="timeline-section">
                <div class="timeline-title">Timeline (scrub through your history)</div>
                <div class="timeline-track" id="tm-timeline"></div>
                <div class="timeline-controls">
                  <button class="btn btn-secondary btn-small" onclick="tmBack()">‚óÄ Back</button>
                  <input type="range" class="timeline-slider" id="tm-slider" min="0" max="0" value="0">
                  <button class="btn btn-secondary btn-small" onclick="tmForward()">Forward ‚ñ∂</button>
                </div>
              </div>
              <div class="state-at-moment">
                <div class="state-panel">
                  <div class="state-panel-title">Game Flags</div>
                  <div id="tm-game-flags"></div>
                </div>
                <div class="state-panel">
                  <div class="state-panel-title">Conv Flags</div>
                  <div id="tm-conv-flags"></div>
                </div>
                <div class="state-panel">
                  <div class="state-panel-title">What Changed Here</div>
                  <div id="tm-changes"></div>
                </div>
              </div>
              <div class="save-slots">
                <div class="save-slot filled" id="save-slot-0" onclick="loadSlot(0)">
                  <div class="save-slot-title">Slot 1</div>
                  <div class="save-slot-preview">üè™</div>
                  <div class="save-slot-info">150g - Node 3</div>
                  <div class="save-slot-actions">
                    <button class="btn btn-small btn-primary">Load</button>
                  </div>
                </div>
                <div class="save-slot" id="save-slot-1" onclick="saveSlot(1)">
                  <div class="save-slot-title">Slot 2</div>
                  <div class="save-slot-empty">Empty</div>
                </div>
                <div class="save-slot" id="save-slot-2" onclick="saveSlot(2)">
                  <div class="save-slot-title">Slot 3</div>
                  <div class="save-slot-empty">Empty</div>
                </div>
                <div class="save-slot" id="save-slot-3" onclick="saveCurrentSlot()">
                  <div class="save-slot-title">+ Save</div>
                  <div class="save-slot-empty">Save Here</div>
                </div>
              </div>
            </div>
          </div>
          <div class="exhibit-controls">
            <button class="btn btn-secondary" onclick="tmRestart()">Restart</button>
            <button class="btn btn-secondary" onclick="tmAutoPlay()">‚ñ∂ Auto-Play</button>
          </div>
        </div>
      </section>
    </main>

    <footer class="test-runner">
      <div class="test-runner-header">
        <h2 class="test-runner-title">Test Suite</h2>
        <div class="test-runner-actions">
          <button class="btn btn-primary" id="run-tests">Run Tests</button>
          <button class="btn btn-secondary" id="run-fuzz" style="display: none;">Run Fuzz Tests</button>
        </div>
      </div>
      <div class="test-runner-content">
        <div class="test-progress">
          <div class="test-progress-bar">
            <div class="test-progress-fill" id="progress-fill"></div>
          </div>
          <div class="test-progress-text" id="progress-text">Ready to run tests</div>
        </div>
        <div class="test-output" id="test-output">
          <div class="test-output-empty">Click "Run Tests" to execute the test suite</div>
        </div>
        <div class="test-summary hidden" id="test-summary">
          <div class="test-summary-item passed">
            <span>‚úì</span>
            <span id="passed-count">0</span> passed
          </div>
          <div class="test-summary-item failed">
            <span>‚úó</span>
            <span id="failed-count">0</span> failed
          </div>
          <div class="test-summary-item skipped">
            <span>‚óã</span>
            <span id="skipped-count">0</span> skipped
          </div>
        </div>
      </div>
    </footer>
  </div>

  <script type="module">
// ============================================
// INLINE LIBRARY CODE
// ============================================

// Error classes
class DialogueError extends Error {
  constructor(message) {
    super(message)
    this.name = 'DialogueError'
  }
}

class ValidationError extends DialogueError {
  constructor(message, field) {
    super(message)
    this.name = 'ValidationError'
    this.field = field
  }
}

class DialogueStructureError extends DialogueError {
  constructor(message, dialogueId, nodeId) {
    super(message)
    this.name = 'DialogueStructureError'
    this.dialogueId = dialogueId
    this.nodeId = nodeId
  }
}

// Forbidden keys for prototype pollution prevention
const FORBIDDEN_KEYS = new Set(['__proto__', 'constructor', 'prototype'])

function safeGet(obj, key) {
  if (typeof key !== 'string') return undefined
  if (FORBIDDEN_KEYS.has(key)) return undefined
  if (!Object.hasOwn(obj, key)) return undefined
  return obj[key]
}

// Create internal flag store
function createInternalFlagStore() {
  const flags = new Map()
  const store = {
    get: (key) => flags.get(key),
    set: (key, value) => { flags.set(key, value); return store },
    has: (key) => flags.has(key),
    delete: (key) => { flags.delete(key); return store },
    clear: () => { flags.clear(); return store },
    increment: (key, amount = 1) => {
      const current = flags.get(key) || 0
      const newValue = current + amount
      flags.set(key, newValue)
      return newValue
    },
    decrement: (key, amount = 1) => {
      const current = flags.get(key) || 0
      const newValue = Math.max(0, current - amount)
      flags.set(key, newValue)
      return newValue
    },
    check: () => true,
    all: () => Object.fromEntries(flags),
    keys: () => Array.from(flags.keys()),
  }
  return store
}

// Parse flag scope
function parseFlagScope(flag) {
  if (flag.startsWith('conv:')) {
    return { scope: 'conv', key: flag.slice(5) }
  }
  if (flag.startsWith('game:')) {
    return { scope: 'game', key: flag.slice(5) }
  }
  return { scope: 'game', key: flag }
}

// Evaluate condition
function evaluateCondition(condition, gameFlags, convFlags) {
  if ('check' in condition) {
    const [flagName, operator, value] = condition.check
    const { scope, key } = parseFlagScope(flagName)
    const store = scope === 'game' ? gameFlags : convFlags
    const storeKey = scope === 'conv' ? key : flagName
    const flagValue = store.get(storeKey)

    switch (operator) {
      case '==': return flagValue === value
      case '!=': return flagValue !== value
      case '>': return flagValue > value
      case '<': return flagValue < value
      case '>=': return flagValue >= value
      case '<=': return flagValue <= value
      default: return false
    }
  }
  if ('and' in condition) {
    return condition.and.every(c => evaluateCondition(c, gameFlags, convFlags))
  }
  if ('or' in condition) {
    return condition.or.some(c => evaluateCondition(c, gameFlags, convFlags))
  }
  if ('not' in condition) {
    return !evaluateCondition(condition.not, gameFlags, convFlags)
  }
  return false
}

// Execute action
async function executeAction(action, gameFlags, convFlags, actionHandlers, onActionExecuted) {
  let result
  try {
    switch (action.type) {
      case 'set': {
        const { scope, key } = parseFlagScope(action.flag)
        const store = scope === 'game' ? gameFlags : convFlags
        const storeKey = scope === 'conv' ? key : action.flag
        store.set(storeKey, action.value)
        result = action.value
        break
      }
      case 'clear': {
        const { scope, key } = parseFlagScope(action.flag)
        const store = scope === 'game' ? gameFlags : convFlags
        const storeKey = scope === 'conv' ? key : action.flag
        store.delete(storeKey)
        result = true
        break
      }
      case 'increment': {
        const { scope, key } = parseFlagScope(action.flag)
        const store = scope === 'game' ? gameFlags : convFlags
        const storeKey = scope === 'conv' ? key : action.flag
        result = store.increment(storeKey, action.value)
        break
      }
      case 'decrement': {
        const { scope, key } = parseFlagScope(action.flag)
        const store = scope === 'game' ? gameFlags : convFlags
        const storeKey = scope === 'conv' ? key : action.flag
        result = store.decrement(storeKey, action.value)
        break
      }
      case 'callback': {
        const handler = safeGet(actionHandlers, action.name)
        if (!handler) throw new Error(`Action handler not registered: ${action.name}`)
        result = await handler(action.args)
        break
      }
    }
    onActionExecuted?.(action, result)
  } catch (error) {
    if (action.type === 'callback' && !actionHandlers[action.name]) throw error
    console.error('Action execution error:', error)
  }
  return result
}

// Interpolate text
async function interpolateText(text, context, customInterpolation, speaker) {
  let result = text
  const matches = Array.from(result.matchAll(/\{\{(\w+(?::\w+)?)\}\}/g))
  for (const match of matches) {
    const key = match[1]
    if (!key) continue
    let value = ''
    const interpolationFn = safeGet(customInterpolation, key)
    if (interpolationFn) {
      const interpolated = await interpolationFn(context)
      value = String(interpolated || '')
    } else if (key === 'speaker' && speaker) {
      value = speaker.name
    } else {
      const { scope, key: flagKey } = parseFlagScope(key)
      const store = scope === 'game' ? context.gameFlags : context.conversationFlags
      const storeKey = scope === 'conv' ? flagKey : key
      const flagValue = store.get(storeKey)
      value = flagValue !== undefined ? String(flagValue) : ''
    }
    result = result.replace(match[0], value)
  }
  return result
}

// Create dialogue runner
function createDialogueRunner(options = {}) {
  const {
    gameFlags = createInternalFlagStore(),
    actionHandlers = {},
    speakers = {},
    i18n,
    interpolation = {},
    onNodeEnter,
    onNodeExit,
    onChoiceSelected,
    onDialogueStart,
    onDialogueEnd,
    onActionExecuted,
    onConditionEvaluated,
  } = options

  if (gameFlags && typeof gameFlags.get !== 'function') {
    throw new ValidationError('gameFlags must be a valid FlagStore', 'gameFlags')
  }
  if (actionHandlers) {
    for (const [key, handler] of Object.entries(actionHandlers)) {
      if (typeof handler !== 'function') {
        throw new ValidationError(`actionHandler "${key}" must be a function`, 'actionHandlers')
      }
    }
  }
  if (i18n) {
    if (typeof i18n.t !== 'function') {
      throw new ValidationError('i18n adapter must have a "t" method', 'i18n')
    }
    if (typeof i18n.hasKey !== 'function') {
      throw new ValidationError('i18n adapter must have a "hasKey" method', 'i18n')
    }
  }

  let currentDialogue = null
  let currentNodeId = null
  let currentInterpolatedNode = null
  let conversationFlags = createInternalFlagStore()
  let history = []

  async function getInterpolatedNode() {
    if (!currentDialogue || !currentNodeId) return null
    const node = currentNodeId ? safeGet(currentDialogue.nodes, currentNodeId) : undefined
    if (!node) return null
    const speaker = node.speaker ? safeGet(speakers, node.speaker) : undefined
    const context = {
      currentNode: node,
      ...(speaker ? { speaker } : {}),
      gameFlags,
      conversationFlags,
    }
    let text = node.text
    if (i18n?.hasKey(text)) text = i18n.t(text, {})
    text = await interpolateText(text, context, interpolation, speaker)
    return { ...node, text }
  }

  async function updateInterpolatedNode() {
    currentInterpolatedNode = await getInterpolatedNode()
  }

  async function processAutoAdvance() {
    if (!currentDialogue || !currentNodeId) return
    const node = currentNodeId ? safeGet(currentDialogue.nodes, currentNodeId) : undefined
    if (!node) return
    if (node.next && (!node.choices || node.choices.length === 0)) {
      onNodeExit?.(node)
      history.push({
        nodeId: currentNodeId,
        node,
        timestamp: Date.now(),
        conversationFlags: { ...conversationFlags.all() },
      })
      currentNodeId = node.next
      const nextNode = currentNodeId ? safeGet(currentDialogue.nodes, currentNodeId) : undefined
      if (nextNode) {
        if (nextNode.actions) {
          for (const action of nextNode.actions) {
            await executeAction(action, gameFlags, conversationFlags, actionHandlers, onActionExecuted)
          }
        }
        await updateInterpolatedNode()
        const speaker = nextNode.speaker ? safeGet(speakers, nextNode.speaker) : undefined
        onNodeEnter?.(nextNode, speaker)
        await processAutoAdvance()
      }
    }
  }

  const runner = {
    start: async (dialogue) => {
      currentDialogue = dialogue
      currentNodeId = dialogue.startNode
      conversationFlags = createInternalFlagStore()
      history = []
      onDialogueStart?.(dialogue)
      const node = currentNodeId ? safeGet(currentDialogue.nodes, currentNodeId) : undefined
      if (!node) throw new ValidationError(`Start node not found: ${dialogue.startNode}`)
      if (node.actions) {
        for (const action of node.actions) {
          await executeAction(action, gameFlags, conversationFlags, actionHandlers, onActionExecuted)
        }
      }
      await updateInterpolatedNode()
      const speaker = node.speaker ? safeGet(speakers, node.speaker) : undefined
      onNodeEnter?.(node, speaker)
      await processAutoAdvance()
      await updateInterpolatedNode()
      const isEnded = runner.isEnded()
      if (isEnded && currentNodeId) {
        const endNode = currentNodeId ? safeGet(currentDialogue.nodes, currentNodeId) : undefined
        if (endNode) onDialogueEnd?.(dialogue.id, endNode)
      }
      if (!currentInterpolatedNode) throw new ValidationError('Failed to initialize dialogue state')
      return {
        currentNode: currentInterpolatedNode,
        availableChoices: runner.getChoices(),
        isEnded,
      }
    },

    getChoices: (options = {}) => {
      if (!currentDialogue || !currentNodeId) return []
      const node = currentNodeId ? safeGet(currentDialogue.nodes, currentNodeId) : undefined
      if (!node?.choices) return []
      const { includeUnavailable = false, includeDisabled = false, filter } = options
      let choices = node.choices
      if (filter) choices = choices.filter(filter)
      if (includeUnavailable) {
        return choices.map(choice => {
          const available = choice.disabled ? false : choice.conditions
            ? evaluateCondition(choice.conditions, gameFlags, conversationFlags)
            : true
          if (choice.conditions && onConditionEvaluated) {
            onConditionEvaluated(choice.conditions, available)
          }
          const result = { ...choice, available }
          if (!available && !choice.disabled && choice.conditions) {
            result.reason = 'Conditions not met'
          }
          return result
        })
      }
      return choices.filter(choice => {
        if (choice.disabled) return includeDisabled
        if (!choice.conditions) return true
        const result = evaluateCondition(choice.conditions, gameFlags, conversationFlags)
        onConditionEvaluated?.(choice.conditions, result)
        return result
      })
    },

    choose: async (index) => {
      if (!currentDialogue || !currentNodeId) throw new ValidationError('No active dialogue')
      if (runner.isEnded()) throw new ValidationError('Dialogue has ended')
      const node = currentNodeId ? safeGet(currentDialogue.nodes, currentNodeId) : undefined
      if (!node?.choices) throw new ValidationError('No choices available')
      if (index < 0 || index >= node.choices.length) throw new ValidationError(`Invalid choice index: ${index}`)
      const choice = node.choices[index]
      if (!choice) throw new ValidationError(`Invalid choice index: ${index}`)
      if (choice.disabled) throw new ValidationError('Cannot select disabled choice')
      if (choice.conditions) {
        const conditionMet = evaluateCondition(choice.conditions, gameFlags, conversationFlags)
        if (!conditionMet) throw new ValidationError('Choice conditions not met')
      }
      onChoiceSelected?.(choice, index)
      onNodeExit?.(node)
      history.push({
        nodeId: currentNodeId,
        node,
        choiceIndex: index,
        choice,
        timestamp: Date.now(),
        conversationFlags: { ...conversationFlags.all() },
      })
      if (choice.actions) {
        for (const action of choice.actions) {
          await executeAction(action, gameFlags, conversationFlags, actionHandlers, onActionExecuted)
        }
      }
      currentNodeId = choice.next
      const nextNode = currentNodeId ? safeGet(currentDialogue.nodes, currentNodeId) : undefined
      if (!nextNode) throw new ValidationError(`Target node not found: ${choice.next}`)
      if (nextNode.actions) {
        for (const action of nextNode.actions) {
          await executeAction(action, gameFlags, conversationFlags, actionHandlers, onActionExecuted)
        }
      }
      await updateInterpolatedNode()
      const speaker = nextNode.speaker ? speakers[nextNode.speaker] : undefined
      onNodeEnter?.(nextNode, speaker)
      await processAutoAdvance()
      await updateInterpolatedNode()
      const isEnded = runner.isEnded()
      if (isEnded && currentNodeId) {
        const endNode = currentNodeId ? safeGet(currentDialogue.nodes, currentNodeId) : undefined
        if (endNode) onDialogueEnd?.(currentDialogue.id, endNode)
      }
      if (!currentInterpolatedNode) throw new ValidationError('Failed to complete choice transition')
      return {
        currentNode: currentInterpolatedNode,
        availableChoices: runner.getChoices(),
        isEnded,
      }
    },

    isEnded: () => {
      if (!currentDialogue || !currentNodeId) return false
      const node = currentNodeId ? safeGet(currentDialogue.nodes, currentNodeId) : undefined
      if (!node) return false
      if (node.isEnd) return true
      if ((!node.choices || node.choices.length === 0) && !node.next) return true
      return false
    },

    getCurrentNode: () => {
      if (currentInterpolatedNode?.isEnd) return null
      return currentInterpolatedNode
    },

    getHistory: () => [...history],

    back: async () => {
      if (history.length === 0) return
      const lastEntry = history.pop()
      if (!lastEntry) return
      currentNodeId = lastEntry.nodeId
      conversationFlags.clear()
      for (const [key, value] of Object.entries(lastEntry.conversationFlags)) {
        conversationFlags.set(key, value)
      }
      await updateInterpolatedNode()
      const node = currentDialogue?.nodes[currentNodeId]
      if (node) {
        const speaker = node.speaker ? safeGet(speakers, node.speaker) : undefined
        onNodeEnter?.(node, speaker)
      }
    },

    restart: async (restartOptions = {}) => {
      if (!currentDialogue) throw new ValidationError('No active dialogue')
      history = []
      const state = await runner.start(currentDialogue)
      if (!restartOptions.preserveConversationFlags) {
        conversationFlags.clear()
        await updateInterpolatedNode()
      }
      return state
    },

    jumpTo: async (nodeId) => {
      if (!currentDialogue) throw new ValidationError('No active dialogue')
      const node = safeGet(currentDialogue.nodes, nodeId)
      if (!node) throw new ValidationError(`Node not found: ${nodeId}`)
      const previousNodeId = currentNodeId
      if (previousNodeId) {
        const prevNode = safeGet(currentDialogue.nodes, previousNodeId)
        if (prevNode) {
          onNodeExit?.(prevNode)
          history.push({
            nodeId: previousNodeId,
            node: prevNode,
            timestamp: Date.now(),
            conversationFlags: { ...conversationFlags.all() },
          })
        }
      }
      currentNodeId = nodeId
      await updateInterpolatedNode()
      const speaker = node.speaker ? safeGet(speakers, node.speaker) : undefined
      onNodeEnter?.(node, speaker)
    },

    serialize: () => {
      if (!currentDialogue || !currentNodeId) throw new ValidationError('No active dialogue to serialize')
      return {
        dialogueId: currentDialogue.id,
        currentNodeId,
        history,
        conversationFlags: conversationFlags.all(),
      }
    },

    deserialize: async (state) => {
      if (!currentDialogue) throw new ValidationError('Start a dialogue before deserializing state')
      currentNodeId = state.currentNodeId
      history = state.history
      conversationFlags = createInternalFlagStore()
      for (const [key, value] of Object.entries(state.conversationFlags)) {
        conversationFlags.set(key, value)
      }
      await updateInterpolatedNode()
      const node = currentNodeId ? safeGet(currentDialogue.nodes, currentNodeId) : undefined
      if (node) {
        const speaker = node.speaker ? safeGet(speakers, node.speaker) : undefined
        onNodeEnter?.(node, speaker)
      }
    },

    getConversationFlags: () => conversationFlags.all(),
    clearConversationFlags: () => conversationFlags.clear(),
    on: () => {},
  }

  return runner
}

// Validate dialogue
function validateDialogue(dialogue) {
  const errors = []
  if (!dialogue.nodes || Object.keys(dialogue.nodes).length === 0) {
    errors.push('Dialogue must have at least one node')
    return { valid: false, errors }
  }
  if (!safeGet(dialogue.nodes, dialogue.startNode)) {
    errors.push(`Start node "${dialogue.startNode}" not found in nodes`)
  }
  const reachable = new Set()
  const toVisit = [dialogue.startNode]
  while (toVisit.length > 0) {
    const nodeId = toVisit.pop()
    if (!nodeId || reachable.has(nodeId)) continue
    reachable.add(nodeId)
    const node = safeGet(dialogue.nodes, nodeId)
    if (!node) continue
    if (node.choices) {
      for (const choice of node.choices) {
        if (!safeGet(dialogue.nodes, choice.next)) {
          errors.push(`Choice in node "${nodeId}" targets non-existent node "${choice.next}"`)
        } else if (!reachable.has(choice.next)) {
          toVisit.push(choice.next)
        }
      }
    }
    if (node.next && !safeGet(dialogue.nodes, node.next)) {
      errors.push(`Node "${nodeId}" auto-advances to non-existent node "${node.next}"`)
    } else if (node.next && !reachable.has(node.next)) {
      toVisit.push(node.next)
    }
  }
  const allNodes = Object.keys(dialogue.nodes)
  const orphans = allNodes.filter(nodeId => !reachable.has(nodeId))
  if (orphans.length > 0) {
    errors.push(`Unreachable nodes: ${orphans.join(', ')}`)
  }
  return { valid: errors.length === 0, errors }
}

// Export for global use
window.createDialogueRunner = createDialogueRunner
window.validateDialogue = validateDialogue
window.createInternalFlagStore = createInternalFlagStore
window.ValidationError = ValidationError
window.DialogueError = DialogueError
window.DialogueStructureError = DialogueStructureError

// ============================================
// EXHIBIT 1: THE CONVERSATION
// ============================================

const merchantDialogue = {
  id: 'merchant-quest',
  startNode: 'greeting',
  nodes: {
    greeting: {
      text: 'Welcome, traveler! You have {{gold}} gold. I have a job for you.',
      speaker: 'merchant',
      choices: [
        { text: 'What kind of job?', next: 'job-details', actions: [{ type: 'set', flag: 'conv:askedJob', value: true }] },
        { text: 'What\'s the pay?', next: 'pay-details', actions: [{ type: 'set', flag: 'conv:askedPay', value: true }] },
        { text: 'Not interested', next: 'decline' }
      ]
    },
    'job-details': {
      text: 'There\'s a bandit camp nearby. Clear it out, and I\'ll make it worth your while.',
      speaker: 'merchant',
      choices: [
        { text: 'What\'s the pay?', next: 'pay-details', actions: [{ type: 'set', flag: 'conv:askedPay', value: true }] },
        { text: 'I\'ll do it!', next: 'accept', actions: [{ type: 'set', flag: 'hasQuest', value: true }] },
        { text: 'Too dangerous', next: 'decline' }
      ]
    },
    'pay-details': {
      text: 'I\'ll pay you 100 gold pieces. You currently have {{gold}} gold - this would help, no?',
      speaker: 'merchant',
      choices: [
        { text: 'Tell me about the job first', next: 'job-details', actions: [{ type: 'set', flag: 'conv:askedJob', value: true }], conditions: { check: ['conv:askedJob', '!=', true] } },
        { text: 'Can you pay more?', next: 'negotiate', conditions: { check: ['reputation', '>=', 20] } },
        { text: 'Deal! I\'ll take it', next: 'accept', actions: [{ type: 'set', flag: 'hasQuest', value: true }] },
        { text: 'Not enough', next: 'decline' }
      ]
    },
    negotiate: {
      text: 'Hmm, you drive a hard bargain. Fine - 120 gold, but only because of your reputation.',
      speaker: 'merchant',
      actions: [{ type: 'set', flag: 'conv:negotiated', value: true }],
      choices: [
        { text: 'Deal!', next: 'accept-bonus', actions: [{ type: 'set', flag: 'hasQuest', value: true }, { type: 'set', flag: 'questReward', value: 120 }] },
        { text: 'Still not enough', next: 'decline' }
      ]
    },
    accept: {
      text: 'Excellent! Come back when the job is done. Good luck out there!',
      speaker: 'merchant',
      actions: [{ type: 'set', flag: 'questReward', value: 100 }],
      isEnd: true
    },
    'accept-bonus': {
      text: 'You\'ve got yourself a deal! 120 gold when you return. Don\'t let me down!',
      speaker: 'merchant',
      isEnd: true
    },
    decline: {
      text: 'Your loss, traveler. Come back if you change your mind.',
      speaker: 'merchant',
      isEnd: true
    }
  }
}

const speakers = {
  merchant: { name: 'Merchant', portrait: 'üè™', color: '#d29922' }
}

let gameFlags = createInternalFlagStore()
gameFlags.set('gold', 150)
gameFlags.set('reputation', 25)
gameFlags.set('hasQuest', false)

let runner
let actionStreamContent = []

function addToActionStream(type, content) {
  actionStreamContent.push({ type, content })
  renderActionStream()
}

function renderActionStream() {
  const container = document.getElementById('action-stream-content')
  container.innerHTML = actionStreamContent.map(item => `
    <div class="action-item">
      <span class="action-type">${item.type}</span>
      <span>${item.content}</span>
    </div>
  `).join('')
  container.scrollTop = container.scrollHeight
}

function renderFlags() {
  const gameContainer = document.getElementById('game-flags')
  const convContainer = document.getElementById('conv-flags')

  const gameFlagsData = gameFlags.all()
  gameContainer.innerHTML = Object.entries(gameFlagsData).map(([key, value]) => {
    if (typeof value === 'number') {
      const max = key === 'gold' ? 250 : key === 'reputation' ? 100 : 100
      const percent = key === 'reputation' ? ((value + 100) / 200) * 100 : (value / max) * 100
      return `
        <div class="flag-item">
          <span class="flag-name">${key}:</span>
          <div class="flag-bar">
            <div class="flag-bar-fill" style="width: ${percent}%"></div>
            <span class="flag-bar-value">${value}</span>
          </div>
        </div>
      `
    } else {
      return `
        <div class="flag-item">
          <span class="flag-name">${key}:</span>
          <div class="flag-bool ${value ? 'true' : 'false'}"></div>
          <span>${value}</span>
        </div>
      `
    }
  }).join('')

  const convFlagsData = runner ? runner.getConversationFlags() : {}
  convContainer.innerHTML = Object.entries(convFlagsData).length === 0
    ? '<div class="flag-item text-muted">No conversation flags set</div>'
    : Object.entries(convFlagsData).map(([key, value]) => `
      <div class="flag-item">
        <span class="flag-name">${key}:</span>
        <div class="flag-bool ${value ? 'true' : 'false'}"></div>
        <span>${value}</span>
      </div>
    `).join('')
}

function renderDialogue(state) {
  const textEl = document.getElementById('dialogue-text')
  const choicesEl = document.getElementById('choices-list')
  const endedEl = document.getElementById('dialogue-ended')
  const portraitEl = document.getElementById('speaker-portrait')
  const nameEl = document.getElementById('speaker-name')

  // Update speaker
  const speakerKey = state.currentNode.speaker
  const speaker = speakerKey ? speakers[speakerKey] : null
  if (speaker) {
    portraitEl.textContent = speaker.portrait
    nameEl.textContent = speaker.name
    portraitEl.classList.add('active')
  } else {
    portraitEl.textContent = 'üë§'
    nameEl.textContent = 'Narrator'
    portraitEl.classList.remove('active')
  }

  // Update text with interpolation highlighting
  let text = state.currentNode.text
  textEl.innerHTML = text

  if (state.isEnded) {
    choicesEl.classList.add('hidden')
    endedEl.classList.remove('hidden')
  } else {
    choicesEl.classList.remove('hidden')
    endedEl.classList.add('hidden')

    // Render choices
    const allChoices = runner.getChoices({ includeUnavailable: true })
    choicesEl.innerHTML = allChoices.map((choice, index) => {
      const hasActions = choice.actions && choice.actions.length > 0
      const isAvailable = choice.available !== false
      return `
        <button class="choice-btn"
                onclick="selectChoice(${index})"
                ${!isAvailable ? 'disabled' : ''}>
          ${hasActions ? '<span class="action-indicator">‚ö°</span>' : ''}
          <span>${choice.text}</span>
          ${!isAvailable ? '<span class="text-muted">(conditions not met)</span>' : ''}
        </button>
      `
    }).join('')
  }

  renderFlags()
}

async function selectChoice(index) {
  try {
    const state = await runner.choose(index)
    renderDialogue(state)
  } catch (err) {
    console.error('Choice error:', err)
  }
}

async function restartDialogue() {
  actionStreamContent = []
  renderActionStream()
  gameFlags = createInternalFlagStore()
  gameFlags.set('gold', 150)
  gameFlags.set('reputation', 25)
  gameFlags.set('hasQuest', false)
  initExhibit1()
}

async function initExhibit1() {
  runner = createDialogueRunner({
    gameFlags,
    speakers,
    onNodeEnter: (node, speaker) => {
      addToActionStream('NODE_ENTER', `"${node.text.substring(0, 30)}..."`)
    },
    onActionExecuted: (action, result) => {
      if (action.type === 'set') {
        addToActionStream('SET', `<span class="action-flag">${action.flag}</span> = <span class="action-value">${action.value}</span>`)
      } else if (action.type === 'increment') {
        addToActionStream('INCREMENT', `<span class="action-flag">${action.flag}</span> by ${action.value || 1}`)
      } else if (action.type === 'decrement') {
        addToActionStream('DECREMENT', `<span class="action-flag">${action.flag}</span> by ${action.value || 1}`)
      }
      renderFlags()
    }
  })

  // Add initial interpolation to action stream
  addToActionStream('INTERPOLATE', '<span class="action-flag">{{gold}}</span> ‚Üí <span class="action-value">"150"</span>')

  const state = await runner.start(merchantDialogue)
  renderDialogue(state)
}

window.selectChoice = selectChoice
window.restartDialogue = restartDialogue

// ============================================
// EXHIBIT 2: THE CONDITION LABORATORY
// ============================================

const labState = {
  gold: 120,
  hasKey: false,
  reputation: 30,
  class: 'warrior'
}

const labConditions = [
  {
    id: 'buy-sword',
    label: 'Buy Sword (100g)',
    condition: { check: ['gold', '>=', 100] },
    description: 'gold >= 100'
  },
  {
    id: 'open-door',
    label: 'Open the Door',
    condition: { or: [{ check: ['hasKey', '==', true] }, { check: ['reputation', '>=', 50] }] },
    description: 'hasKey OR reputation >= 50'
  },
  {
    id: 'buy-armor',
    label: 'Buy Heavy Armor (200g)',
    condition: { and: [{ check: ['gold', '>=', 200] }, { not: { check: ['class', '==', 'mage'] } }] },
    description: 'gold >= 200 AND NOT mage'
  },
  {
    id: 'cast-fireball',
    label: 'Cast Fireball',
    condition: { check: ['class', '==', 'mage'] },
    description: 'class == mage'
  }
]

function evaluateLabCondition(condition) {
  if ('check' in condition) {
    const [flag, op, value] = condition.check
    const flagValue = labState[flag]
    switch (op) {
      case '==': return flagValue === value
      case '!=': return flagValue !== value
      case '>=': return flagValue >= value
      case '<=': return flagValue <= value
      case '>': return flagValue > value
      case '<': return flagValue < value
    }
  }
  if ('and' in condition) {
    return condition.and.every(c => evaluateLabCondition(c))
  }
  if ('or' in condition) {
    return condition.or.some(c => evaluateLabCondition(c))
  }
  if ('not' in condition) {
    return !evaluateLabCondition(condition.not)
  }
  return false
}

function renderLabConditions() {
  const conditionsEl = document.getElementById('lab-conditions')
  const outputsEl = document.getElementById('lab-outputs')

  conditionsEl.innerHTML = labConditions.map(cond => {
    const result = evaluateLabCondition(cond.condition)
    return `
      <div class="condition-row">
        <div class="condition-wire ${result ? 'active' : ''}"></div>
        <div class="condition-check">${cond.description}</div>
        <div class="condition-status ${result ? 'pass' : 'fail'}">${result ? '‚úì PASS' : '‚úó FAIL'}</div>
        <div class="condition-wire ${result ? 'active' : ''}"></div>
      </div>
    `
  }).join('')

  outputsEl.innerHTML = labConditions.map(cond => {
    const result = evaluateLabCondition(cond.condition)
    return `
      <div class="output-row">
        <div class="output-bulb ${result ? 'lit' : ''}"></div>
        <span class="output-text">"${cond.label}"</span>
        <span class="output-status ${result ? 'available' : ''}">${result ? '[AVAILABLE]' : '[LOCKED]'}</span>
      </div>
    `
  }).join('')
}

function updateLabInput(input, value) {
  labState[input] = value
  renderLabConditions()
}

function toggleLabSwitch(input) {
  labState[input] = !labState[input]
  const track = document.getElementById(`lab-${input}`)
  const label = document.getElementById(`lab-${input}-label`)
  track.classList.toggle('on', labState[input])
  label.textContent = labState[input] ? 'ON' : 'OFF'
  renderLabConditions()
}

function randomizeLabInputs() {
  labState.gold = Math.floor(Math.random() * 250)
  labState.hasKey = Math.random() > 0.5
  labState.reputation = Math.floor(Math.random() * 200) - 100
  labState.class = ['warrior', 'mage', 'rogue'][Math.floor(Math.random() * 3)]

  document.getElementById('lab-gold').value = labState.gold
  document.getElementById('lab-gold-value').textContent = labState.gold
  document.getElementById('lab-reputation').value = labState.reputation
  document.getElementById('lab-reputation-value').textContent = labState.reputation
  document.getElementById('lab-class').value = labState.class

  const keyTrack = document.getElementById('lab-hasKey')
  const keyLabel = document.getElementById('lab-hasKey-label')
  keyTrack.classList.toggle('on', labState.hasKey)
  keyLabel.textContent = labState.hasKey ? 'ON' : 'OFF'

  renderLabConditions()
}

function initExhibit2() {
  document.getElementById('lab-gold').addEventListener('input', (e) => {
    const value = parseInt(e.target.value)
    document.getElementById('lab-gold-value').textContent = value
    updateLabInput('gold', value)
  })

  document.getElementById('lab-reputation').addEventListener('input', (e) => {
    const value = parseInt(e.target.value)
    document.getElementById('lab-reputation-value').textContent = value
    updateLabInput('reputation', value)
  })

  document.getElementById('lab-class').addEventListener('change', (e) => {
    updateLabInput('class', e.target.value)
  })

  renderLabConditions()
}

window.toggleLabSwitch = toggleLabSwitch
window.randomizeLabInputs = randomizeLabInputs

// ============================================
// EXHIBIT 3: THE TIME MACHINE
// ============================================

const tmDialogue = {
  id: 'time-machine-demo',
  startNode: 'node1',
  nodes: {
    node1: {
      text: 'Welcome, traveler! You have 150 gold.',
      speaker: 'merchant',
      choices: [
        { text: 'What kind of work?', next: 'node2', actions: [{ type: 'set', flag: 'conv:askedJob', value: true }] }
      ]
    },
    node2: {
      text: 'I need someone to clear out some bandits.',
      speaker: 'merchant',
      choices: [
        { text: 'What\'s the reward?', next: 'node3', actions: [{ type: 'set', flag: 'conv:askedPay', value: true }] }
      ]
    },
    node3: {
      text: 'I\'ll pay you 100 gold pieces.',
      speaker: 'merchant',
      choices: [
        { text: 'Can you pay more?', next: 'node4' }
      ]
    },
    node4: {
      text: 'Hmm, you drive a hard bargain...',
      speaker: 'merchant',
      actions: [{ type: 'increment', flag: 'conv:negotiationRounds', value: 1 }],
      choices: [
        { text: 'How about 120 gold?', next: 'node5' }
      ]
    },
    node5: {
      text: 'Fine, 120 gold. But that\'s my final offer.',
      speaker: 'merchant',
      choices: [
        { text: 'Deal!', next: 'node6', actions: [{ type: 'set', flag: 'hasQuest', value: true }] }
      ]
    },
    node6: {
      text: 'Excellent! Come back when the job is done.',
      speaker: 'merchant',
      isEnd: true
    }
  }
}

let tmRunner
let tmGameFlags
let tmHistory = []
let tmCurrentIndex = 5
let tmSaveSlots = [
  { nodeId: 'node3', gold: 150, convFlags: { askedJob: true, askedPay: true }, timestamp: Date.now() - 60000 },
  null,
  null,
  null
]

// Pre-populate the timeline
const prePopulatedHistory = [
  { nodeId: 'node1', text: 'Welcome, traveler!', speaker: 'üè™', change: 'NODE_ENTER' },
  { nodeId: 'node2', text: 'I need someone to...', speaker: 'üè™', change: 'SET conv:askedJob = true' },
  { nodeId: 'node3', text: 'I\'ll pay you 100...', speaker: 'üè™', change: 'SET conv:askedPay = true' },
  { nodeId: 'node4', text: 'Hmm, you drive a...', speaker: 'üè™', change: 'INCREMENT negotiationRounds' },
  { nodeId: 'node5', text: 'Fine, 120 gold...', speaker: 'üè™', change: 'NODE_ENTER' },
  { nodeId: 'node6', text: 'Excellent! Come back...', speaker: 'üè™', change: 'SET hasQuest = true' }
]

function renderTimeMachine() {
  const timelineEl = document.getElementById('tm-timeline')
  const currentTextEl = document.getElementById('tm-current-text')
  const choicesEl = document.getElementById('tm-choices')
  const gameFlagsEl = document.getElementById('tm-game-flags')
  const convFlagsEl = document.getElementById('tm-conv-flags')
  const changesEl = document.getElementById('tm-changes')
  const sliderEl = document.getElementById('tm-slider')

  // Render timeline
  timelineEl.innerHTML = prePopulatedHistory.map((entry, index) => `
    <div class="timeline-node ${index === tmCurrentIndex ? 'current' : ''}" onclick="tmJumpTo(${index})">
      <div class="timeline-node-number">${index + 1}</div>
      <div class="timeline-node-icon">${entry.speaker}</div>
    </div>
    ${index < prePopulatedHistory.length - 1 ? '<div class="timeline-connector"></div>' : ''}
  `).join('')

  // Update slider
  sliderEl.max = prePopulatedHistory.length - 1
  sliderEl.value = tmCurrentIndex

  // Render current state
  const current = prePopulatedHistory[tmCurrentIndex]
  currentTextEl.textContent = tmDialogue.nodes[current.nodeId].text

  // Render choices
  const node = tmDialogue.nodes[current.nodeId]
  if (node.isEnd) {
    choicesEl.innerHTML = '<div class="text-muted">Dialogue has ended.</div>'
  } else if (node.choices) {
    choicesEl.innerHTML = node.choices.map((choice, i) => `
      <button class="choice-btn" onclick="tmChoose(${i})">${choice.text}</button>
    `).join('')
  }

  // Render flags
  const goldValues = [150, 150, 150, 150, 150, 150]
  gameFlagsEl.innerHTML = `
    <div class="flag-item">
      <span class="flag-name">gold:</span>
      <div class="flag-bar">
        <div class="flag-bar-fill" style="width: 60%"></div>
        <span class="flag-bar-value">${goldValues[tmCurrentIndex]}</span>
      </div>
    </div>
    <div class="flag-item">
      <span class="flag-name">hasQuest:</span>
      <div class="flag-bool ${tmCurrentIndex === 5 ? 'true' : 'false'}"></div>
    </div>
  `

  convFlagsEl.innerHTML = `
    <div class="flag-item">
      <span class="flag-name">askedJob:</span>
      <div class="flag-bool ${tmCurrentIndex >= 1 ? 'true' : 'false'}"></div>
    </div>
    <div class="flag-item">
      <span class="flag-name">askedPay:</span>
      <div class="flag-bool ${tmCurrentIndex >= 2 ? 'true' : 'false'}"></div>
    </div>
  `

  changesEl.innerHTML = `<div class="text-secondary">${current.change}</div>`

  // Render save slots
  tmSaveSlots.forEach((slot, i) => {
    const el = document.getElementById(`save-slot-${i}`)
    if (slot) {
      el.className = 'save-slot filled'
      el.innerHTML = `
        <div class="save-slot-title">Slot ${i + 1}</div>
        <div class="save-slot-preview">üè™</div>
        <div class="save-slot-info">${slot.gold}g - Node ${slot.nodeId.replace('node', '')}</div>
        <div class="save-slot-actions">
          <button class="btn btn-small btn-primary" onclick="loadSlot(${i}); event.stopPropagation();">Load</button>
        </div>
      `
    }
  })
}

function tmJumpTo(index) {
  tmCurrentIndex = index
  renderTimeMachine()
}

function tmBack() {
  if (tmCurrentIndex > 0) {
    tmCurrentIndex--
    renderTimeMachine()
  }
}

function tmForward() {
  if (tmCurrentIndex < prePopulatedHistory.length - 1) {
    tmCurrentIndex++
    renderTimeMachine()
  }
}

function tmChoose(index) {
  if (tmCurrentIndex < prePopulatedHistory.length - 1) {
    tmCurrentIndex++
    renderTimeMachine()
  }
}

function tmRestart() {
  tmCurrentIndex = 0
  renderTimeMachine()
}

function tmAutoPlay() {
  tmCurrentIndex = 0
  renderTimeMachine()
  let i = 0
  const interval = setInterval(() => {
    if (i < prePopulatedHistory.length - 1) {
      i++
      tmCurrentIndex = i
      renderTimeMachine()
    } else {
      clearInterval(interval)
    }
  }, 1000)
}

function loadSlot(index) {
  const slot = tmSaveSlots[index]
  if (slot) {
    const nodeIndex = parseInt(slot.nodeId.replace('node', '')) - 1
    tmCurrentIndex = nodeIndex
    renderTimeMachine()
  }
}

function saveSlot(index) {
  const current = prePopulatedHistory[tmCurrentIndex]
  tmSaveSlots[index] = {
    nodeId: current.nodeId,
    gold: 150,
    convFlags: {},
    timestamp: Date.now()
  }
  renderTimeMachine()
}

function saveCurrentSlot() {
  // Find first empty slot
  const emptyIndex = tmSaveSlots.findIndex(s => s === null)
  if (emptyIndex >= 0) {
    saveSlot(emptyIndex)
  }
}

function initExhibit3() {
  document.getElementById('tm-slider').addEventListener('input', (e) => {
    tmCurrentIndex = parseInt(e.target.value)
    renderTimeMachine()
  })
  renderTimeMachine()
}

window.tmJumpTo = tmJumpTo
window.tmBack = tmBack
window.tmForward = tmForward
window.tmChoose = tmChoose
window.tmRestart = tmRestart
window.tmAutoPlay = tmAutoPlay
window.loadSlot = loadSlot
window.saveSlot = saveSlot
window.saveCurrentSlot = saveCurrentSlot

// ============================================
// TEST RUNNER
// ============================================

const testRunner = {
  tests: [],
  results: [],
  running: false,

  register(name, fn) {
    this.tests.push({ name, fn })
  },

  async run() {
    if (this.running) return
    this.running = true
    this.results = []

    const output = document.getElementById('test-output')
    const progressFill = document.getElementById('progress-fill')
    const progressText = document.getElementById('progress-text')
    const summary = document.getElementById('test-summary')
    const passedCount = document.getElementById('passed-count')
    const failedCount = document.getElementById('failed-count')
    const skippedCount = document.getElementById('skipped-count')
    const runBtn = document.getElementById('run-tests')

    runBtn.disabled = true
    output.innerHTML = ''
    summary.classList.add('hidden')
    progressFill.style.width = '0%'
    progressFill.className = 'test-progress-fill'

    let passed = 0
    let failed = 0

    for (let i = 0; i < this.tests.length; i++) {
      const test = this.tests[i]
      const progress = ((i + 1) / this.tests.length) * 100

      progressFill.style.width = `${progress}%`
      progressText.textContent = `Running: ${test.name}`

      try {
        await test.fn()
        passed++
        this.results.push({ name: test.name, passed: true })
        output.innerHTML += `
          <div class="test-item">
            <span class="test-icon pass">‚úì</span>
            <span class="test-name">${escapeHtml(test.name)}</span>
          </div>
        `
      } catch (e) {
        failed++
        this.results.push({ name: test.name, passed: false, error: e.message })
        output.innerHTML += `
          <div class="test-item">
            <span class="test-icon fail">‚úó</span>
            <div>
              <div class="test-name">${escapeHtml(test.name)}</div>
              <div class="test-error">${escapeHtml(e.message)}</div>
            </div>
          </div>
        `
      }

      output.scrollTop = output.scrollHeight
      await new Promise(r => setTimeout(r, 20))
    }

    progressFill.classList.add(failed === 0 ? 'success' : 'failure')
    progressText.textContent = `Complete: ${passed}/${this.tests.length} passed`

    passedCount.textContent = passed
    failedCount.textContent = failed
    skippedCount.textContent = 0
    summary.classList.remove('hidden')

    runBtn.disabled = false
    this.running = false
  }
}

function escapeHtml(str) {
  return str
    .replace(/&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;')
}

// Register tests
testRunner.register('creates runner with minimal options', () => {
  const runner = createDialogueRunner()
  if (!runner) throw new Error('Expected runner to be created')
  if (typeof runner.start !== 'function') throw new Error('Expected start method')
})

testRunner.register('creates runner with gameFlags store', () => {
  const gameFlags = createInternalFlagStore()
  const runner = createDialogueRunner({ gameFlags })
  if (!runner) throw new Error('Expected runner to be created')
})

testRunner.register('returns object with all expected methods', () => {
  const runner = createDialogueRunner()
  const methods = ['start', 'getChoices', 'choose', 'isEnded', 'getCurrentNode', 'getHistory', 'back', 'restart', 'jumpTo', 'serialize', 'deserialize', 'getConversationFlags', 'clearConversationFlags', 'on']
  for (const method of methods) {
    if (typeof runner[method] !== 'function') throw new Error(`Expected ${method} method`)
  }
})

testRunner.register('starts dialogue at startNode', async () => {
  const runner = createDialogueRunner()
  const dialogue = { id: 'test', startNode: 'start', nodes: { start: { text: 'Hello!' } } }
  const state = await runner.start(dialogue)
  if (state.currentNode.text !== 'Hello!') throw new Error('Expected correct start node')
})

testRunner.register('returns current node state', async () => {
  const runner = createDialogueRunner()
  const dialogue = { id: 'test', startNode: 'start', nodes: { start: { text: 'Test', choices: [{ text: 'Go', next: 'end' }] }, end: { text: 'End' } } }
  const state = await runner.start(dialogue)
  if (!state.currentNode) throw new Error('Expected currentNode')
  if (!state.availableChoices) throw new Error('Expected availableChoices')
  if (typeof state.isEnded !== 'boolean') throw new Error('Expected isEnded boolean')
})

testRunner.register('returns available choices for current node', async () => {
  const runner = createDialogueRunner()
  const dialogue = { id: 'test', startNode: 'start', nodes: { start: { text: 'Test', choices: [{ text: 'A', next: 'end' }, { text: 'B', next: 'end' }] }, end: { text: 'End' } } }
  await runner.start(dialogue)
  const choices = runner.getChoices()
  if (choices.length !== 2) throw new Error('Expected 2 choices')
})

testRunner.register('excludes choices where conditions fail', async () => {
  const gameFlags = createInternalFlagStore()
  gameFlags.set('hasKey', false)
  const runner = createDialogueRunner({ gameFlags })
  const dialogue = { id: 'test', startNode: 'start', nodes: { start: { text: 'Door', choices: [{ text: 'Open', next: 'end', conditions: { check: ['hasKey', '==', true] } }, { text: 'Leave', next: 'end' }] }, end: { text: 'End' } } }
  await runner.start(dialogue)
  const choices = runner.getChoices()
  if (choices.length !== 1) throw new Error('Expected 1 available choice')
  if (choices[0].text !== 'Leave') throw new Error('Expected Leave choice')
})

testRunner.register('advances to next node by choice index', async () => {
  const runner = createDialogueRunner()
  const dialogue = { id: 'test', startNode: 'start', nodes: { start: { text: 'Start', choices: [{ text: 'Go', next: 'end' }] }, end: { text: 'The End' } } }
  await runner.start(dialogue)
  const state = await runner.choose(0)
  if (state.currentNode.text !== 'The End') throw new Error('Expected to advance to end node')
})

testRunner.register('throws ValidationError for invalid index', async () => {
  const runner = createDialogueRunner()
  const dialogue = { id: 'test', startNode: 'start', nodes: { start: { text: 'Start', choices: [{ text: 'Go', next: 'end' }] }, end: { text: 'End' } } }
  await runner.start(dialogue)
  try {
    await runner.choose(99)
    throw new Error('Expected ValidationError')
  } catch (e) {
    if (e.name !== 'ValidationError') throw new Error('Expected ValidationError')
  }
})

testRunner.register('returns true at terminal node', async () => {
  const runner = createDialogueRunner()
  const dialogue = { id: 'test', startNode: 'start', nodes: { start: { text: 'Start', choices: [{ text: 'End', next: 'end' }] }, end: { text: 'End', isEnd: true } } }
  await runner.start(dialogue)
  await runner.choose(0)
  if (!runner.isEnded()) throw new Error('Expected isEnded to be true')
})

testRunner.register('records each node visited in history', async () => {
  const runner = createDialogueRunner()
  const dialogue = { id: 'test', startNode: 'start', nodes: { start: { text: 'Start', choices: [{ text: 'Go', next: 'middle' }] }, middle: { text: 'Middle', choices: [{ text: 'End', next: 'end' }] }, end: { text: 'End' } } }
  await runner.start(dialogue)
  await runner.choose(0)
  await runner.choose(0)
  const history = runner.getHistory()
  if (history.length !== 2) throw new Error('Expected 2 history entries')
})

testRunner.register('back() returns to previous node', async () => {
  const runner = createDialogueRunner()
  const dialogue = { id: 'test', startNode: 'start', nodes: { start: { text: 'Start', choices: [{ text: 'Go', next: 'end' }] }, end: { text: 'End' } } }
  await runner.start(dialogue)
  await runner.choose(0)
  await runner.back()
  const node = runner.getCurrentNode()
  if (node.text !== 'Start') throw new Error('Expected to return to Start')
})

testRunner.register('restart() returns to start node', async () => {
  const runner = createDialogueRunner()
  const dialogue = { id: 'test', startNode: 'start', nodes: { start: { text: 'Start', choices: [{ text: 'Go', next: 'end' }] }, end: { text: 'End' } } }
  await runner.start(dialogue)
  await runner.choose(0)
  const state = await runner.restart()
  if (state.currentNode.text !== 'Start') throw new Error('Expected to restart at Start')
})

testRunner.register('jumpTo() jumps to specified node', async () => {
  const runner = createDialogueRunner()
  const dialogue = { id: 'test', startNode: 'start', nodes: { start: { text: 'Start' }, middle: { text: 'Middle' }, end: { text: 'End' } } }
  await runner.start(dialogue)
  await runner.jumpTo('middle')
  const node = runner.getCurrentNode()
  if (node.text !== 'Middle') throw new Error('Expected to jump to Middle')
})

testRunner.register('serialize() returns JSON-compatible object', async () => {
  const runner = createDialogueRunner()
  const dialogue = { id: 'test', startNode: 'start', nodes: { start: { text: 'Start' } } }
  await runner.start(dialogue)
  const state = runner.serialize()
  try {
    JSON.stringify(state)
  } catch (e) {
    throw new Error('Expected JSON-compatible object')
  }
})

testRunner.register('deserialize() restores current node', async () => {
  const runner = createDialogueRunner()
  const dialogue = { id: 'test', startNode: 'start', nodes: { start: { text: 'Start' }, middle: { text: 'Middle' } } }
  await runner.start(dialogue)
  await runner.jumpTo('middle')
  const state = runner.serialize()

  const runner2 = createDialogueRunner()
  await runner2.start(dialogue)
  await runner2.deserialize(state)
  const node = runner2.getCurrentNode()
  if (node.text !== 'Middle') throw new Error('Expected to restore to Middle')
})

testRunner.register('interpolates text variables', async () => {
  const gameFlags = createInternalFlagStore()
  gameFlags.set('playerName', 'Hero')
  const runner = createDialogueRunner({ gameFlags })
  const dialogue = { id: 'test', startNode: 'start', nodes: { start: { text: 'Hello {{playerName}}!' } } }
  const state = await runner.start(dialogue)
  if (state.currentNode.text !== 'Hello Hero!') throw new Error('Expected interpolated text')
})

testRunner.register('executes node actions on entry', async () => {
  const gameFlags = createInternalFlagStore()
  const runner = createDialogueRunner({ gameFlags })
  const dialogue = { id: 'test', startNode: 'start', nodes: { start: { text: 'Start', actions: [{ type: 'set', flag: 'visited', value: true }] } } }
  await runner.start(dialogue)
  if (gameFlags.get('visited') !== true) throw new Error('Expected action to execute')
})

testRunner.register('executes choice actions on selection', async () => {
  const gameFlags = createInternalFlagStore()
  const runner = createDialogueRunner({ gameFlags })
  const dialogue = { id: 'test', startNode: 'start', nodes: { start: { text: 'Start', choices: [{ text: 'Go', next: 'end', actions: [{ type: 'set', flag: 'chosen', value: true }] }] }, end: { text: 'End' } } }
  await runner.start(dialogue)
  await runner.choose(0)
  if (gameFlags.get('chosen') !== true) throw new Error('Expected choice action to execute')
})

testRunner.register('conversation flags cleared on new dialogue', async () => {
  const runner = createDialogueRunner()
  const dialogue1 = { id: 'test1', startNode: 'start', nodes: { start: { text: 'Start', actions: [{ type: 'set', flag: 'conv:temp', value: true }] } } }
  await runner.start(dialogue1)
  const flags1 = runner.getConversationFlags()
  if (flags1['temp'] !== true) throw new Error('Expected conv flag to be set')

  const dialogue2 = { id: 'test2', startNode: 'start', nodes: { start: { text: 'Start' } } }
  await runner.start(dialogue2)
  const flags2 = runner.getConversationFlags()
  if (flags2['temp'] !== undefined) throw new Error('Expected conv flag to be cleared')
})

testRunner.register('evaluates AND conditions', async () => {
  const gameFlags = createInternalFlagStore()
  gameFlags.set('hasKey', true)
  gameFlags.set('hasMap', true)
  const runner = createDialogueRunner({ gameFlags })
  const dialogue = { id: 'test', startNode: 'start', nodes: { start: { text: 'Start', choices: [{ text: 'Go', next: 'end', conditions: { and: [{ check: ['hasKey', '==', true] }, { check: ['hasMap', '==', true] }] } }] }, end: { text: 'End' } } }
  await runner.start(dialogue)
  const choices = runner.getChoices()
  if (choices.length !== 1) throw new Error('Expected AND condition to pass')
})

testRunner.register('evaluates OR conditions', async () => {
  const gameFlags = createInternalFlagStore()
  gameFlags.set('hasKey', false)
  gameFlags.set('hasLockpick', true)
  const runner = createDialogueRunner({ gameFlags })
  const dialogue = { id: 'test', startNode: 'start', nodes: { start: { text: 'Start', choices: [{ text: 'Go', next: 'end', conditions: { or: [{ check: ['hasKey', '==', true] }, { check: ['hasLockpick', '==', true] }] } }] }, end: { text: 'End' } } }
  await runner.start(dialogue)
  const choices = runner.getChoices()
  if (choices.length !== 1) throw new Error('Expected OR condition to pass')
})

testRunner.register('evaluates NOT conditions', async () => {
  const gameFlags = createInternalFlagStore()
  gameFlags.set('isDead', false)
  const runner = createDialogueRunner({ gameFlags })
  const dialogue = { id: 'test', startNode: 'start', nodes: { start: { text: 'Start', choices: [{ text: 'Go', next: 'end', conditions: { not: { check: ['isDead', '==', true] } } }] }, end: { text: 'End' } } }
  await runner.start(dialogue)
  const choices = runner.getChoices()
  if (choices.length !== 1) throw new Error('Expected NOT condition to pass')
})

testRunner.register('validateDialogue returns valid for good dialogue', () => {
  const dialogue = { id: 'test', startNode: 'start', nodes: { start: { text: 'Start', choices: [{ text: 'Go', next: 'end' }] }, end: { text: 'End' } } }
  const result = validateDialogue(dialogue)
  if (!result.valid) throw new Error('Expected valid dialogue')
})

testRunner.register('validateDialogue returns invalid for missing startNode', () => {
  const dialogue = { id: 'test', startNode: 'nonexistent', nodes: { start: { text: 'Start' } } }
  const result = validateDialogue(dialogue)
  if (result.valid) throw new Error('Expected invalid dialogue')
})

testRunner.register('validateDialogue returns invalid for orphan nodes', () => {
  const dialogue = { id: 'test', startNode: 'start', nodes: { start: { text: 'Start', isEnd: true }, orphan: { text: 'Orphan' } } }
  const result = validateDialogue(dialogue)
  if (result.valid) throw new Error('Expected invalid dialogue with orphan nodes')
})

testRunner.register('handles unicode in text', async () => {
  const runner = createDialogueRunner()
  const dialogue = { id: 'test', startNode: 'start', nodes: { start: { text: '„Åì„Çì„Å´„Å°„ÅØ‰∏ñÁïå üåç' } } }
  const state = await runner.start(dialogue)
  if (state.currentNode.text !== '„Åì„Çì„Å´„Å°„ÅØ‰∏ñÁïå üåç') throw new Error('Expected unicode text')
})

testRunner.register('handles circular dialogue references', async () => {
  const runner = createDialogueRunner()
  const dialogue = { id: 'test', startNode: 'loop', nodes: { loop: { text: 'Loop', choices: [{ text: 'Again', next: 'loop' }] } } }
  await runner.start(dialogue)
  await runner.choose(0)
  await runner.choose(0)
  const node = runner.getCurrentNode()
  if (node.text !== 'Loop') throw new Error('Expected to handle circular references')
})

testRunner.register('rejects __proto__ as node ID', async () => {
  const runner = createDialogueRunner()
  const dialogue = { id: 'test', startNode: '__proto__', nodes: { '__proto__': { text: 'Malicious' } } }
  try {
    await runner.start(dialogue)
    throw new Error('Expected ValidationError')
  } catch (e) {
    if (e.name !== 'ValidationError') throw new Error('Expected ValidationError for __proto__')
  }
})

testRunner.register('disabled choices excluded by default', async () => {
  const runner = createDialogueRunner()
  const dialogue = { id: 'test', startNode: 'start', nodes: { start: { text: 'Start', choices: [{ text: 'Disabled', next: 'end', disabled: true }, { text: 'Enabled', next: 'end' }] }, end: { text: 'End' } } }
  await runner.start(dialogue)
  const choices = runner.getChoices()
  if (choices.length !== 1) throw new Error('Expected disabled choice to be excluded')
  if (choices[0].text !== 'Enabled') throw new Error('Expected only enabled choice')
})

testRunner.register('includeUnavailable shows all choices with availability', async () => {
  const gameFlags = createInternalFlagStore()
  gameFlags.set('hasKey', false)
  const runner = createDialogueRunner({ gameFlags })
  const dialogue = { id: 'test', startNode: 'start', nodes: { start: { text: 'Door', choices: [{ text: 'Open', next: 'end', conditions: { check: ['hasKey', '==', true] } }, { text: 'Leave', next: 'end' }] }, end: { text: 'End' } } }
  await runner.start(dialogue)
  const choices = runner.getChoices({ includeUnavailable: true })
  if (choices.length !== 2) throw new Error('Expected 2 choices with includeUnavailable')
  if (choices[0].available !== false) throw new Error('Expected first choice to be unavailable')
})

testRunner.register('auto-advances when node has next but no choices', async () => {
  const runner = createDialogueRunner()
  const dialogue = { id: 'test', startNode: 'start', nodes: { start: { text: 'Start', next: 'middle' }, middle: { text: 'Middle' } } }
  const state = await runner.start(dialogue)
  if (state.currentNode.text !== 'Middle') throw new Error('Expected auto-advance to Middle')
})

testRunner.register('increment action increases flag value', async () => {
  const gameFlags = createInternalFlagStore()
  gameFlags.set('count', 5)
  const runner = createDialogueRunner({ gameFlags })
  const dialogue = { id: 'test', startNode: 'start', nodes: { start: { text: 'Start', actions: [{ type: 'increment', flag: 'count', value: 3 }] } } }
  await runner.start(dialogue)
  if (gameFlags.get('count') !== 8) throw new Error('Expected count to be 8')
})

testRunner.register('decrement action decreases flag value', async () => {
  const gameFlags = createInternalFlagStore()
  gameFlags.set('count', 10)
  const runner = createDialogueRunner({ gameFlags })
  const dialogue = { id: 'test', startNode: 'start', nodes: { start: { text: 'Start', actions: [{ type: 'decrement', flag: 'count', value: 3 }] } } }
  await runner.start(dialogue)
  if (gameFlags.get('count') !== 7) throw new Error('Expected count to be 7')
})

testRunner.register('clear action removes flag', async () => {
  const gameFlags = createInternalFlagStore()
  gameFlags.set('temp', true)
  const runner = createDialogueRunner({ gameFlags })
  const dialogue = { id: 'test', startNode: 'start', nodes: { start: { text: 'Start', actions: [{ type: 'clear', flag: 'temp' }] } } }
  await runner.start(dialogue)
  if (gameFlags.get('temp') !== undefined) throw new Error('Expected temp flag to be cleared')
})

document.getElementById('run-tests').addEventListener('click', () => testRunner.run())

// ============================================
// INITIALIZATION
// ============================================

document.addEventListener('DOMContentLoaded', () => {
  initExhibit1()
  initExhibit2()
  initExhibit3()
})
  </script>
</body>
</html>
